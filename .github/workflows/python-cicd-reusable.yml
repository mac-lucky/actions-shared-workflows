---
name: Reusable Python CI/CD Workflow

on:
  workflow_call:
    secrets:
      DOCKER_HUB_USERNAME:
        description: 'Docker Hub username'
        required: true
      DOCKER_HUB_PASSWORD:
        description: 'Docker Hub password/token'
        required: true
    inputs:
      # Application configuration
      app_name:
        description: 'Application name'
        required: true
        type: string
      dockerhub_image:
        description: 'Docker Hub image name (e.g., maclucky/app-name)'
        required: true
        type: string
      ghcr_image:
        description: 'GHCR image name (e.g., ghcr.io/mac-lucky/app-name)'
        required: true
        type: string
      
      # Build configuration
      dockerfile_path:
        description: 'Path to Dockerfile'
        required: false
        type: string
        default: './Dockerfile'
      build_context:
        description: 'Build context path'
        required: false
        type: string
        default: '.'
      requirements_path:
        description: 'Path to requirements.txt'
        required: false
        type: string
        default: './requirements.txt'
      
      # Test configuration
      enable_container_tests:
        description: 'Enable container integration tests'
        required: false
        type: boolean
        default: true
      enable_kubernetes_tests:
        description: 'Enable Kubernetes integration tests'
        required: false
        type: boolean
        default: false
      helm_chart_path:
        description: 'Path to Helm chart for Kubernetes tests'
        required: false
        type: string
        default: ''
      helm_release_name:
        description: 'Helm release name for deployment'
        required: false
        type: string
        default: ''
      app_label_selector:
        description: 'App label selector for Kubernetes pods (e.g., ping-exporter, tcp-endpoint-check-exporter)'
        required: false
        type: string
        default: ''
      
      # Security and quality
      enable_security_scan:
        description: 'Enable security scanning with Trivy'
        required: false
        type: boolean
        default: true
      enable_sbom:
        description: 'Generate Software Bill of Materials'
        required: false
        type: boolean
        default: true
      
      # Deployment
      enable_auto_version:
        description: 'Enable automatic version increment'
        required: false
        type: boolean
        default: true
      push_on_main:
        description: 'Push images when merging to main branch'
        required: false
        type: boolean
        default: true

env:
  REGISTRY_IMAGE_DOCKERHUB: ${{ inputs.dockerhub_image }}
  REGISTRY_IMAGE_GHCR: ${{ inputs.ghcr_image }}

jobs:
  # Job 1: Check for code changes
  check-changes:
    name: Check for Code Changes
    runs-on: ubuntu-latest
    outputs:
      code-changed: ${{ steps.changes.outputs.code }}
      workflow-changed: ${{ steps.changes.outputs.workflow-changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check for code changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            echo "Release event - forcing build"
            echo "code=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For push events, check if there are changes to Python code
          if [ "${{ github.event_name }}" = "push" ]; then
            # Check if previous commit exists
            if git rev-parse HEAD~1 >/dev/null 2>&1; then
              # Check for changes in Python-related files
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
              
              # Check for workflow changes
              if echo "$CHANGED_FILES" | grep -E '\.github/workflows/.*\.yml$' > /dev/null; then
                echo "Workflow changes detected - running tests only:"
                echo "$CHANGED_FILES" | grep -E '\.github/workflows/.*\.yml$'
                echo "code=false" >> $GITHUB_OUTPUT
                echo "workflow-changed=true" >> $GITHUB_OUTPUT
              # Look for changes in Python files, requirements.txt, Dockerfile, or src directories
              elif echo "$CHANGED_FILES" | grep -E '\.(py|txt)$|Dockerfile|^(src|app|python)/' > /dev/null; then
                echo "Code changes detected:"
                echo "$CHANGED_FILES" | grep -E '\.(py|txt)$|Dockerfile|^(src|app|python)/'
                echo "code=true" >> $GITHUB_OUTPUT
                echo "workflow-changed=false" >> $GITHUB_OUTPUT
              else
                echo "No code changes detected. Only documentation/config changes:"
                echo "$CHANGED_FILES"
                echo "code=false" >> $GITHUB_OUTPUT
                echo "workflow-changed=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "First commit - forcing build"
              echo "code=true" >> $GITHUB_OUTPUT
              echo "workflow-changed=false" >> $GITHUB_OUTPUT
            fi
          else
            # For PR events, always run tests but don't push
            echo "Pull request - running tests only"
            echo "code=false" >> $GITHUB_OUTPUT
            echo "workflow-changed=false" >> $GITHUB_OUTPUT
          fi

  setup:
    name: Setup Build Environment
    runs-on: ubuntu-latest
    needs: check-changes
    outputs:
      python-version: ${{ steps.python-version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Extract Python version from Dockerfile
        id: python-version
        run: |
          # Extract Python version from Dockerfile
          PYTHON_VERSION=$(grep -E '^FROM python:' ${{ inputs.dockerfile_path }} | head -1 | sed -E 's/.*python:([0-9]+)(\.[0-9]+)?(-.*)?.*/\1\2/')
          if [ -z "$PYTHON_VERSION" ]; then
            PYTHON_VERSION="3.12"
          fi
          echo "Found Python version in Dockerfile: $PYTHON_VERSION"

          # Set version for builds
          echo "version=$PYTHON_VERSION" >> $GITHUB_OUTPUT

  # Job 3: Code Quality & Security Analysis
  code-analysis:
    name: Code Quality & Security Analysis
    runs-on: ubuntu-latest
    needs: [check-changes, setup]
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ needs.setup.outputs.python-version }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          if [ -f "${{ inputs.requirements_path }}" ]; then
            pip install -r ${{ inputs.requirements_path }}
          else
            echo "No requirements.txt found, skipping dependency installation"
          fi

      - name: Install development dependencies
        run: |
          pip install flake8 black isort bandit safety

      - name: Run flake8
        run: |
          # Find all Python files and run flake8
          find . -name "*.py" -not -path "./.*" | head -20 | xargs flake8 --max-line-length=120 --ignore=E203,W503 || true

      - name: Run black check
        run: |
          # Check code formatting with black
          find . -name "*.py" -not -path "./.*" | head -20 | xargs black --check --line-length=120 || true

      - name: Run isort check
        run: |
          # Check import sorting with isort
          find . -name "*.py" -not -path "./.*" | head -20 | xargs isort --check-only --profile black || true

      - name: Run bandit security scan
        run: |
          # Run bandit security linter
          find . -name "*.py" -not -path "./.*" | head -20 | xargs bandit -r . -f json -o bandit-report.json || true

      - name: Run safety check
        run: |
          # Check for known security vulnerabilities in dependencies
          if [ -f "${{ inputs.requirements_path }}" ]; then
            safety check -r ${{ inputs.requirements_path }} || true
          fi

      - name: Run Trivy vulnerability scanner
        if: ${{ inputs.enable_security_scan }}
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "table"

  # Job 4: Build Container Image
  build-container:
    name: Build Container Image
    runs-on: ubuntu-latest
    needs: [check-changes, setup, code-analysis]
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build container
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.build_context }}
          file: ${{ inputs.dockerfile_path }}
          tags: ${{ inputs.app_name }}:test
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: false
          load: true
          build-args: |
            PYTHON_VERSION=${{ needs.setup.outputs.python-version }}

      - name: Save container image
        if: ${{ inputs.enable_kubernetes_tests || inputs.enable_container_tests }}
        run: |
          docker save ${{ inputs.app_name }}:test | \
            gzip > /tmp/${{ inputs.app_name }}.tar.gz

      - name: Upload container artifact
        if: ${{ inputs.enable_kubernetes_tests || inputs.enable_container_tests }}
        uses: actions/upload-artifact@v4
        with:
          name: container-image
          path: /tmp/${{ inputs.app_name }}.tar.gz
          retention-days: 1

  # Job 5: Container Integration Tests
  container-test:
    name: Container Integration Test
    runs-on: ubuntu-latest
    needs: [check-changes, setup, build-container]
    if: ${{ inputs.enable_container_tests }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download container artifact
        uses: actions/download-artifact@v5
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          gunzip -c /tmp/${{ inputs.app_name }}.tar.gz | docker load
          docker image ls -a

      - name: Basic container functionality test
        run: |
          echo "Running basic container test for ${{ inputs.app_name }}"
          docker run -d --name test-container ${{ inputs.app_name }}:test
          sleep 10
          
          # Basic health check - this should be customized per application
          if docker ps | grep -q test-container; then
            echo "✅ Container is running"
          else
            echo "❌ Container failed to start"
            docker logs test-container
            exit 1
          fi
          
          docker stop test-container
          docker rm test-container

      - name: Container security scan
        if: ${{ inputs.enable_security_scan }}
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "${{ inputs.app_name }}:test"
          format: "table"
          exit-code: "0"
          ignore-unfixed: true

  # Job 6: Kubernetes Integration Tests (Optional)
  kubernetes-test:
    name: Kubernetes Integration Test
    runs-on: ubuntu-latest
    needs: [check-changes, setup, build-container]
    if: ${{ inputs.enable_kubernetes_tests && inputs.helm_chart_path != '' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download container artifact
        uses: actions/download-artifact@v5
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          gunzip -c /tmp/${{ inputs.app_name }}.tar.gz | docker load
          docker image ls -a

      - name: Setup Minikube with 2 nodes
        uses: medyagh/setup-minikube@latest
        with:
          minikube-version: 'latest'
          driver: docker
          container-runtime: docker
          kubernetes-version: v1.32.0
          cpus: 2
          memory: 2048m
          addons: metrics-server
          start-args: '--nodes=2'

      - name: Load Docker image into Minikube
        run: |
          minikube image load ${{ inputs.app_name }}:test

      - name: Create monitoring namespace
        run: |
          kubectl create namespace monitoring || true

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Deploy application with Helm
        run: |
          RELEASE_NAME="${{ inputs.helm_release_name }}"
          if [ -z "$RELEASE_NAME" ]; then
            RELEASE_NAME="${{ inputs.app_name }}"
          fi
          
          helm upgrade --install $RELEASE_NAME ${{ inputs.helm_chart_path }} \
            --namespace monitoring \
            --set image.tag=test \
            --set image.repository=${{ inputs.app_name }} \
            --set image.pullPolicy=Never \
            --set serviceMonitor.enabled=false \
            --wait --timeout=300s

      - name: Verify deployment
        run: |
          APP_LABEL="${{ inputs.app_label_selector }}"
          if [ -z "$APP_LABEL" ]; then
            APP_LABEL="${{ inputs.app_name }}"
          fi
          
          echo "=== Checking deployment status ==="
          kubectl get pods -n monitoring -l app=$APP_LABEL -o wide
          kubectl get services -n monitoring
          kubectl get configmap -n monitoring

      - name: Wait for pods to be ready
        run: |
          APP_LABEL="${{ inputs.app_label_selector }}"
          if [ -z "$APP_LABEL" ]; then
            APP_LABEL="${{ inputs.app_name }}"
          fi
          
          kubectl wait --for=condition=ready pod -l app=$APP_LABEL \
            -n monitoring --timeout=120s

      - name: Health check
        run: |
          APP_LABEL="${{ inputs.app_label_selector }}"
          if [ -z "$APP_LABEL" ]; then
            APP_LABEL="${{ inputs.app_name }}"
          fi
          
          echo "=== Health check ==="
          # Check if all pods are running
          READY_PODS=$(kubectl get pods -n monitoring -l app=$APP_LABEL \
            -o jsonpath='{.items[*].status.phase}' | grep -o Running | wc -l)
          TOTAL_PODS=$(kubectl get pods -n monitoring \
            -l app=$APP_LABEL --no-headers | wc -l)
          echo "Ready pods: $READY_PODS / $TOTAL_PODS"
          if [ "$READY_PODS" -eq "$TOTAL_PODS" ] && \
             [ "$TOTAL_PODS" -gt 0 ]; then
            echo "✅ All pods are running successfully"
          else
            echo "❌ Not all pods are running"
            kubectl describe pods -n monitoring -l app=$APP_LABEL
            exit 1
          fi

      - name: Cleanup
        if: always()
        run: |
          RELEASE_NAME="${{ inputs.helm_release_name }}"
          if [ -z "$RELEASE_NAME" ]; then
            RELEASE_NAME="${{ inputs.app_name }}"
          fi
          
          helm uninstall $RELEASE_NAME -n monitoring || true
          kubectl delete namespace monitoring || true

  # Job 7: Build and Push Multi-arch Container Images
  build-and-push:
    name: Build & Push Container Images
    runs-on: ubuntu-latest
    needs: [check-changes, setup, build-container, container-test, kubernetes-test]
    if: ${{ ((github.event_name == 'push' && inputs.push_on_main) || github.event_name == 'release') && github.ref == 'refs/heads/master' && needs.check-changes.outputs.code-changed == 'true' && needs.check-changes.outputs.workflow-changed != 'true' && (always() && (inputs.enable_container_tests == false || needs.container-test.result == 'success' || needs.container-test.result == 'skipped') && (inputs.enable_kubernetes_tests == false || needs.kubernetes-test.result == 'success' || needs.kubernetes-test.result == 'skipped')) }}
    permissions:
      contents: read
      packages: write
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-flags: --debug

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
          logout: false

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}
          logout: false

      - name: Get latest version tag
        if: ${{ inputs.enable_auto_version }}
        id: get_latest_version
        run: |
          LATEST_TAG=$(curl -s \
            "https://registry.hub.docker.com/v2/repositories/${{ env.REGISTRY_IMAGE_DOCKERHUB }}/tags?page_size=100" | \
            jq -r '.results[].name' | \
            grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | \
            sort -V | tail -n 1 || echo "")
          echo "LATEST_TAG=${LATEST_TAG}" >> $GITHUB_ENV

      - name: Set version
        id: set_version
        run: |
          if [ "${{ inputs.enable_auto_version }}" = "true" ]; then
            VERSION=${{ env.LATEST_TAG }}
            if [ -z "$VERSION" ]; then
              NEW_VERSION="1.0.0"
            else
              NEW_VERSION=$(echo $VERSION | awk -F. -v OFS=. '{$NF++;print}')
            fi
          else
            # Use git tag or default version
            NEW_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "1.0.0")
          fi
          echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_ENV

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.build_context }}
          file: ${{ inputs.dockerfile_path }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.REGISTRY_IMAGE_DOCKERHUB }}:${{ env.NEW_VERSION }}
            ${{ env.REGISTRY_IMAGE_DOCKERHUB }}:latest
            ${{ env.REGISTRY_IMAGE_GHCR }}:${{ env.NEW_VERSION }}
            ${{ env.REGISTRY_IMAGE_GHCR }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            PYTHON_VERSION=${{ needs.setup.outputs.python-version }}
            VERSION=${{ env.NEW_VERSION }}
            COMMIT_SHA=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}

      - name: Generate SBOM
        if: ${{ inputs.enable_sbom }}
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY_IMAGE_GHCR }}:${{ env.NEW_VERSION }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM artifact
        if: ${{ inputs.enable_sbom }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json

  # Job 8: Post-deployment verification
  post-deploy-verify:
    name: Post-deployment Verification
    runs-on: ubuntu-latest
    needs: [check-changes, build-and-push]
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.check-changes.outputs.workflow-changed != 'true' }}
    steps:
      - name: Verify image pull and functionality
        run: |
          echo "Verifying images can be pulled..."
          docker pull ${{ env.REGISTRY_IMAGE_DOCKERHUB }}:latest
          
          echo "✅ Image verification successful"
