---
name: Reusable Python CI/CD Workflow

on:
  workflow_call:
    secrets:
      DOCKER_HUB_USERNAME:
        description: 'Docker Hub username'
        required: false
      DOCKER_HUB_PASSWORD:
        description: 'Docker Hub password/token'
        required: false
    inputs:
      # Application configuration
      app_name:
        description: 'Application name'
        required: true
        type: string
      dockerhub_image:
        description: 'Docker Hub image name (e.g., maclucky/app-name)'
        required: true
        type: string
      ghcr_image:
        description: 'GHCR image name (e.g., ghcr.io/mac-lucky/app-name)'
        required: true
        type: string

      # Build configuration
      dockerfile_path:
        description: 'Path to Dockerfile'
        required: false
        type: string
        default: './Dockerfile'
      build_context:
        description: 'Build context path'
        required: false
        type: string
        default: '.'

      # Package manager configuration
      use_uv:
        description: 'Use uv package manager instead of pip'
        required: false
        type: boolean
        default: true
      python_version:
        description: 'Python version to use (if not auto-detected from Dockerfile)'
        required: false
        type: string
        default: '3.12'

      # Test configuration
      enable_container_tests:
        description: 'Enable container integration tests'
        required: false
        type: boolean
        default: true
      enable_kubernetes_tests:
        description: 'Enable Kubernetes integration tests'
        required: false
        type: boolean
        default: false
      helm_chart_path:
        description: 'Path to Helm chart for Kubernetes tests'
        required: false
        type: string
        default: ''
      helm_release_name:
        description: 'Helm release name for deployment'
        required: false
        type: string
        default: ''
      app_label_selector:
        description: 'App label selector for Kubernetes pods (e.g., ping-exporter, tcp-endpoint-check-exporter)'
        required: false
        type: string
        default: ''

      # Security and quality
      enable_security_scan:
        description: 'Enable security scanning with Trivy'
        required: false
        type: boolean
        default: true
      enable_sbom:
        description: 'Generate Software Bill of Materials'
        required: false
        type: boolean
        default: true
      enable_code_analysis:
        description: 'Enable code analysis (linting, formatting checks)'
        required: false
        type: boolean
        default: true

      # Deployment
      enable_auto_version:
        description: 'Enable automatic version increment'
        required: false
        type: boolean
        default: true
      push_on_main:
        description: 'Push images when merging to main branch'
        required: false
        type: boolean
        default: true
      push_to_dockerhub:
        description: 'Push images to Docker Hub (in addition to GHCR)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY_IMAGE_DOCKERHUB: ${{ inputs.dockerhub_image }}
  REGISTRY_IMAGE_GHCR: ${{ inputs.ghcr_image }}

jobs:
  # Job 1: Check for code changes
  check-changes:
    name: Check for Code Changes
    runs-on: ubuntu-latest
    outputs:
      code-changed: ${{ steps.changes.outputs.code }}
      workflow-changed: ${{ steps.changes.outputs.workflow-changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check for code changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            echo "Release event - forcing build"
            echo "code=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # For push events, check if there are changes to Python code
          if [ "${{ github.event_name }}" = "push" ]; then
            # Check if previous commit exists
            if git rev-parse HEAD~1 >/dev/null 2>&1; then
              # Check for changes in Python-related files
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)

              # Check for workflow changes
              if echo "$CHANGED_FILES" | grep -E '\.github/workflows/.*\.yml$' > /dev/null; then
                echo "Workflow changes detected - running tests only:"
                echo "$CHANGED_FILES" | grep -E '\.github/workflows/.*\.yml$'
                echo "code=false" >> $GITHUB_OUTPUT
                echo "workflow-changed=true" >> $GITHUB_OUTPUT
              # Look for changes in Python files, pyproject.toml, uv.lock, Dockerfile, or src directories
              elif echo "$CHANGED_FILES" | grep -E '\.(py|toml|lock)$|Dockerfile|^(src|app|python)/' > /dev/null; then
                echo "Code changes detected:"
                echo "$CHANGED_FILES" | grep -E '\.(py|toml|lock)$|Dockerfile|^(src|app|python)/'
                echo "code=true" >> $GITHUB_OUTPUT
                echo "workflow-changed=false" >> $GITHUB_OUTPUT
              else
                echo "No code changes detected. Only documentation/config changes:"
                echo "$CHANGED_FILES"
                echo "code=false" >> $GITHUB_OUTPUT
                echo "workflow-changed=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "First commit - forcing build"
              echo "code=true" >> $GITHUB_OUTPUT
              echo "workflow-changed=false" >> $GITHUB_OUTPUT
            fi
          else
            # For PR events, always run tests but don't push
            echo "Pull request - running tests only"
            echo "code=false" >> $GITHUB_OUTPUT
            echo "workflow-changed=false" >> $GITHUB_OUTPUT
          fi

  setup:
    name: Setup Build Environment
    runs-on: ubuntu-latest
    needs: check-changes
    outputs:
      python-version: ${{ steps.python-version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Extract Python version
        id: python-version
        run: |
          # Try to extract from Dockerfile first
          if [ -f "${{ inputs.dockerfile_path }}" ]; then
            PYTHON_VERSION=$(grep -E '^FROM.*python:' ${{ inputs.dockerfile_path }} | head -1 | sed -E 's/.*python:([0-9]+\.[0-9]+).*/\1/')
          fi

          # Try .python-version file
          if [ -z "$PYTHON_VERSION" ] && [ -f "${{ inputs.build_context }}/.python-version" ]; then
            PYTHON_VERSION=$(cat "${{ inputs.build_context }}/.python-version" | tr -d '[:space:]')
          fi

          # Try pyproject.toml
          if [ -z "$PYTHON_VERSION" ] && [ -f "${{ inputs.build_context }}/pyproject.toml" ]; then
            PYTHON_VERSION=$(grep -E 'requires-python' "${{ inputs.build_context }}/pyproject.toml" | sed -E 's/.*>=([0-9]+\.[0-9]+).*/\1/' | head -1)
          fi

          # Fallback to input or default
          if [ -z "$PYTHON_VERSION" ]; then
            PYTHON_VERSION="${{ inputs.python_version }}"
          fi

          echo "Found Python version: $PYTHON_VERSION"
          echo "version=$PYTHON_VERSION" >> $GITHUB_OUTPUT

  # Job 3: Code Quality & Security Analysis
  code-analysis:
    name: Code Quality & Security Analysis
    runs-on: ubuntu-latest
    needs: [check-changes, setup]
    if: ${{ inputs.enable_code_analysis }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install uv
        if: ${{ inputs.use_uv }}
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ needs.setup.outputs.python-version }}

      - name: Install dependencies with uv
        if: ${{ inputs.use_uv }}
        working-directory: ${{ inputs.build_context }}
        run: |
          if [ -f "pyproject.toml" ]; then
            uv sync --frozen 2>/dev/null || uv sync
          else
            echo "No pyproject.toml found, skipping dependency installation"
          fi

      - name: Install development tools
        run: |
          if [ "${{ inputs.use_uv }}" = "true" ]; then
            uv tool install ruff
            uv tool install bandit
          else
            pip install ruff bandit
          fi

      - name: Run ruff linter
        working-directory: ${{ inputs.build_context }}
        run: |
          ruff check . --output-format=github || true

      - name: Run ruff formatter check
        working-directory: ${{ inputs.build_context }}
        run: |
          ruff format --check . || true

      - name: Run bandit security scan
        working-directory: ${{ inputs.build_context }}
        run: |
          bandit -r . -f json -o bandit-report.json --exclude .venv,.git || true

      - name: Run Trivy vulnerability scanner
        if: ${{ inputs.enable_security_scan }}
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: ${{ inputs.build_context }}
          format: "table"

  # Job 4: Build Container Image
  build-container:
    name: Build Container Image
    runs-on: ubuntu-latest
    needs: [check-changes, setup, code-analysis]
    if: ${{ always() && (needs.code-analysis.result == 'success' || needs.code-analysis.result == 'skipped') }}
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build container
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.build_context }}
          file: ${{ inputs.dockerfile_path }}
          tags: ${{ inputs.app_name }}:test
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: false
          load: true
          build-args: |
            PYTHON_VERSION=${{ needs.setup.outputs.python-version }}

      - name: Save container image
        if: ${{ inputs.enable_kubernetes_tests || inputs.enable_container_tests }}
        run: |
          docker save ${{ inputs.app_name }}:test | \
            gzip > /tmp/${{ inputs.app_name }}.tar.gz

      - name: Upload container artifact
        if: ${{ inputs.enable_kubernetes_tests || inputs.enable_container_tests }}
        uses: actions/upload-artifact@v4
        with:
          name: container-image
          path: /tmp/${{ inputs.app_name }}.tar.gz
          retention-days: 1

  # Job 5: Container Integration Tests
  container-test:
    name: Container Integration Test
    runs-on: ubuntu-latest
    needs: [check-changes, setup, build-container]
    if: ${{ inputs.enable_container_tests && needs.build-container.result == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download container artifact
        uses: actions/download-artifact@v4
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          gunzip -c /tmp/${{ inputs.app_name }}.tar.gz | docker load
          docker image ls -a

      - name: Basic container functionality test
        run: |
          echo "Running basic container test for ${{ inputs.app_name }}"
          docker run -d --name test-container ${{ inputs.app_name }}:test
          sleep 10

          # Basic health check - this should be customized per application
          if docker ps | grep -q test-container; then
            echo "✅ Container is running"
          else
            echo "❌ Container failed to start"
            docker logs test-container
            exit 1
          fi

          docker stop test-container
          docker rm test-container

      - name: Container security scan
        if: ${{ inputs.enable_security_scan }}
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: "${{ inputs.app_name }}:test"
          format: "table"
          exit-code: "0"
          ignore-unfixed: true

  # Job 6: Kubernetes Integration Tests (Optional)
  kubernetes-test:
    name: Kubernetes Integration Test
    runs-on: ubuntu-latest
    needs: [check-changes, setup, build-container]
    if: ${{ inputs.enable_kubernetes_tests && inputs.helm_chart_path != '' && needs.build-container.result == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download container artifact
        uses: actions/download-artifact@v4
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          gunzip -c /tmp/${{ inputs.app_name }}.tar.gz | docker load
          docker image ls -a

      - name: Setup Minikube with 2 nodes
        uses: medyagh/setup-minikube@latest
        with:
          minikube-version: 'latest'
          driver: docker
          container-runtime: docker
          kubernetes-version: v1.32.0
          cpus: 2
          memory: 2048m
          addons: metrics-server
          start-args: '--nodes=2'

      - name: Load Docker image into Minikube
        run: |
          minikube image load ${{ inputs.app_name }}:test

      - name: Create monitoring namespace
        run: |
          kubectl create namespace monitoring || true

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Deploy application with Helm
        run: |
          RELEASE_NAME="${{ inputs.helm_release_name }}"
          if [ -z "$RELEASE_NAME" ]; then
            RELEASE_NAME="${{ inputs.app_name }}"
          fi

          helm upgrade --install $RELEASE_NAME ${{ inputs.helm_chart_path }} \
            --namespace monitoring \
            --set image.tag=test \
            --set image.repository=${{ inputs.app_name }} \
            --set image.pullPolicy=Never \
            --set serviceMonitor.enabled=false \
            --wait --timeout=300s

      - name: Verify deployment
        run: |
          APP_LABEL="${{ inputs.app_label_selector }}"
          if [ -z "$APP_LABEL" ]; then
            APP_LABEL="${{ inputs.app_name }}"
          fi

          echo "=== Checking deployment status ==="
          kubectl get pods -n monitoring -l app=$APP_LABEL -o wide
          kubectl get services -n monitoring
          kubectl get configmap -n monitoring

      - name: Wait for pods to be ready
        run: |
          APP_LABEL="${{ inputs.app_label_selector }}"
          if [ -z "$APP_LABEL" ]; then
            APP_LABEL="${{ inputs.app_name }}"
          fi

          kubectl wait --for=condition=ready pod -l app=$APP_LABEL \
            -n monitoring --timeout=120s

      - name: Health check
        run: |
          APP_LABEL="${{ inputs.app_label_selector }}"
          if [ -z "$APP_LABEL" ]; then
            APP_LABEL="${{ inputs.app_name }}"
          fi

          echo "=== Health check ==="
          # Check if all pods are running
          READY_PODS=$(kubectl get pods -n monitoring -l app=$APP_LABEL \
            -o jsonpath='{.items[*].status.phase}' | grep -o Running | wc -l)
          TOTAL_PODS=$(kubectl get pods -n monitoring \
            -l app=$APP_LABEL --no-headers | wc -l)
          echo "Ready pods: $READY_PODS / $TOTAL_PODS"
          if [ "$READY_PODS" -eq "$TOTAL_PODS" ] && \
             [ "$TOTAL_PODS" -gt 0 ]; then
            echo "✅ All pods are running successfully"
          else
            echo "❌ Not all pods are running"
            kubectl describe pods -n monitoring -l app=$APP_LABEL
            exit 1
          fi

      - name: Cleanup
        if: always()
        run: |
          RELEASE_NAME="${{ inputs.helm_release_name }}"
          if [ -z "$RELEASE_NAME" ]; then
            RELEASE_NAME="${{ inputs.app_name }}"
          fi

          helm uninstall $RELEASE_NAME -n monitoring || true
          kubectl delete namespace monitoring || true

  # Job 7: Build and Push Multi-arch Container Images
  build-and-push:
    name: Build & Push Container Images
    runs-on: ubuntu-latest
    needs: [check-changes, setup, build-container, container-test, kubernetes-test]
    if: ${{ ((github.event_name == 'push' && inputs.push_on_main) || github.event_name == 'release') && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main') && needs.check-changes.outputs.code-changed == 'true' && needs.check-changes.outputs.workflow-changed != 'true' && (always() && (inputs.enable_container_tests == false || needs.container-test.result == 'success' || needs.container-test.result == 'skipped') && (inputs.enable_kubernetes_tests == false || needs.kubernetes-test.result == 'success' || needs.kubernetes-test.result == 'skipped')) }}
    permissions:
      contents: read
      packages: write
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-flags: --debug

      - name: Log in to Docker Hub
        if: ${{ inputs.push_to_dockerhub }}
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
          logout: false

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}
          logout: false

      - name: Get latest version tag
        if: ${{ inputs.enable_auto_version }}
        id: get_latest_version
        run: |
          # Extract image name from GHCR URL (e.g., ghcr.io/mac-lucky/app-name -> app-name)
          IMAGE_NAME=$(echo "${{ env.REGISTRY_IMAGE_GHCR }}" | sed 's|.*/||')
          OWNER=$(echo "${{ env.REGISTRY_IMAGE_GHCR }}" | sed 's|ghcr.io/||' | sed 's|/.*||')

          # Get tags from GHCR using GitHub API
          LATEST_TAG=$(curl -s \
            -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/users/$OWNER/packages/container/$IMAGE_NAME/versions?per_page=100" | \
            jq -r '.[].metadata.container.tags[]' | \
            grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | \
            sort -V | tail -n 1 || echo "")
          echo "LATEST_TAG=${LATEST_TAG}" >> $GITHUB_ENV

      - name: Set version
        id: set_version
        run: |
          if [ "${{ inputs.enable_auto_version }}" = "true" ]; then
            VERSION=${{ env.LATEST_TAG }}
            if [ -z "$VERSION" ]; then
              NEW_VERSION="0.1.0"
            else
              NEW_VERSION=$(echo $VERSION | awk -F. -v OFS=. '{$NF++;print}')
            fi
          else
            # Use git tag or default version
            NEW_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.1.0")
          fi
          echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_ENV

      - name: Generate tags
        id: generate_tags
        run: |
          TAGS="${{ env.REGISTRY_IMAGE_GHCR }}:${{ env.NEW_VERSION }},${{ env.REGISTRY_IMAGE_GHCR }}:latest"
          if [ "${{ inputs.push_to_dockerhub }}" = "true" ]; then
            TAGS="${TAGS},${{ env.REGISTRY_IMAGE_DOCKERHUB }}:${{ env.NEW_VERSION }},${{ env.REGISTRY_IMAGE_DOCKERHUB }}:latest"
          fi
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.build_context }}
          file: ${{ inputs.dockerfile_path }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.generate_tags.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            PYTHON_VERSION=${{ needs.setup.outputs.python-version }}
            VERSION=${{ env.NEW_VERSION }}
            COMMIT_SHA=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}

      - name: Generate SBOM
        if: ${{ inputs.enable_sbom }}
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY_IMAGE_GHCR }}:${{ env.NEW_VERSION }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM artifact
        if: ${{ inputs.enable_sbom }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json

  # Job 8: Post-deployment verification
  post-deploy-verify:
    name: Post-deployment Verification
    runs-on: ubuntu-latest
    needs: [check-changes, build-and-push]
    if: ${{ github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main') && needs.check-changes.outputs.workflow-changed != 'true' }}
    steps:
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}

      - name: Verify image pull and functionality
        run: |
          echo "Verifying images can be pulled from GHCR..."
          docker pull ${{ env.REGISTRY_IMAGE_GHCR }}:latest

          echo "✅ Image verification successful"
