---
name: Reusable Dependabot Auto-Merge Workflow

on:
  workflow_call:
    inputs:
      # CI check configuration
      code_analysis_check_name:
        description: 'Name of the code analysis check to wait for'
        required: false
        type: string
        default: 'Code Quality & Security Analysis'
      container_test_check_name:
        description: 'Name of the container test check to wait for'
        required: false
        type: string
        default: 'Container Integration Test'
      kubernetes_test_check_name:
        description: 'Name of the Kubernetes test check to wait for (optional)'
        required: false
        type: string
        default: ''
      
      # Auto-merge configuration
      enable_auto_merge:
        description: 'Enable auto-merge for dependabot PRs'
        required: false
        type: boolean
        default: true
      merge_method:
        description: 'Merge method (merge, squash, rebase)'
        required: false
        type: string
        default: 'squash'
      delete_branch:
        description: 'Delete branch after merge'
        required: false
        type: boolean
        default: true
      
      # Update type filters
      allow_patch:
        description: 'Allow auto-merge for patch updates'
        required: false
        type: boolean
        default: true
      allow_minor:
        description: 'Allow auto-merge for minor updates'
        required: false
        type: boolean
        default: true
      allow_major:
        description: 'Allow auto-merge for major updates'
        required: false
        type: boolean
        default: false
      
      # Additional filters
      additional_keywords:
        description: 'Additional keywords to allow auto-merge (comma-separated)'
        required: false
        type: string
        default: 'deps,ci,docker'

permissions:
  contents: write
  pull-requests: write
  actions: write
  checks: read
  statuses: read

jobs:
  auto-merge:
    name: Auto-merge Dependabot PRs
    runs-on: ubuntu-latest
    timeout-minutes: 40
    if: github.actor == 'dependabot[bot]' && (github.event_name == 'pull_request' || github.event_name == 'pull_request_target')
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          token: ${{ github.token }}

      - name: Get PR details
        id: pr-details
        run: |
          echo "title=${{ github.event.pull_request.title }}" >> $GITHUB_OUTPUT
          echo "author=${{ github.event.pull_request.user.login }}" >> $GITHUB_OUTPUT

      - name: Wait for code analysis checks
        id: wait-for-code-analysis
        env:
          CHECK_NAME: ${{ inputs.code_analysis_check_name }}
          GH_TOKEN: ${{ github.token }}
          CHECK_TIMEOUT: 1800
        run: |
          set -euo pipefail

          if [ -z "$CHECK_NAME" ]; then
            echo "No code analysis check specified. Marking as skipped."
            echo "check_name=" >> "$GITHUB_OUTPUT"
            echo "conclusion=skipped" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          SHA="${{ github.event.pull_request.head.sha }}"
          REPO="$GITHUB_REPOSITORY"
          deadline=$((SECONDS + CHECK_TIMEOUT))

          while [ $SECONDS -lt $deadline ]; do
            MATCHED=0
            runs=$(gh api repos/$REPO/commits/$SHA/check-runs --paginate --jq '.check_runs[] | [.name, .status, (.conclusion // "")] | @tsv' || true)

            if [ -n "$runs" ]; then
              while IFS=$'\t' read -r name status conclusion; do
                [ -z "$name" ] && continue

                if [[ "$name" == "$CHECK_NAME" || "$name" == *" / $CHECK_NAME" || "$name" == *"$CHECK_NAME" ]]; then
                  MATCHED=1
                  human_conclusion=${conclusion:-pending}
                  echo "Found check run '$name' (status: $status, conclusion: $human_conclusion)"

                  if [[ "$status" == "completed" ]]; then
                    conclusion=${conclusion:-unknown}
                    echo "check_name=$name" >> "$GITHUB_OUTPUT"
                    echo "conclusion=$conclusion" >> "$GITHUB_OUTPUT"

                    if [[ "$conclusion" == "success" || "$conclusion" == "neutral" || "$conclusion" == "skipped" ]]; then
                      echo "Check '$name' completed with conclusion '$conclusion' (treated as pass)"
                      exit 0
                    else
                      echo "::error::Check '$name' completed with conclusion '$conclusion'"
                      exit 1
                    fi
                  fi
                fi
              done <<< "$runs"
            fi

            if [[ $MATCHED -eq 0 ]]; then
              echo "Waiting for check matching '$CHECK_NAME' to start..."
            else
              echo "Check found but not completed yet. Waiting..."
            fi

            sleep 30
          done

          echo "check_name=" >> "$GITHUB_OUTPUT"
          echo "conclusion=timed_out" >> "$GITHUB_OUTPUT"
          echo "::error::Timed out waiting for check matching '$CHECK_NAME'"
          exit 1

      - name: Wait for container test
        if: ${{ inputs.container_test_check_name != '' }}
        id: wait-for-container-test
        env:
          CHECK_NAME: ${{ inputs.container_test_check_name }}
          GH_TOKEN: ${{ github.token }}
          CHECK_TIMEOUT: 1800
        run: |
          set -euo pipefail

          SHA="${{ github.event.pull_request.head.sha }}"
          REPO="$GITHUB_REPOSITORY"
          deadline=$((SECONDS + CHECK_TIMEOUT))

          while [ $SECONDS -lt $deadline ]; do
            MATCHED=0
            runs=$(gh api repos/$REPO/commits/$SHA/check-runs --paginate --jq '.check_runs[] | [.name, .status, (.conclusion // "")] | @tsv' || true)

            if [ -n "$runs" ]; then
              while IFS=$'\t' read -r name status conclusion; do
                [ -z "$name" ] && continue

                if [[ "$name" == "$CHECK_NAME" || "$name" == *" / $CHECK_NAME" || "$name" == *"$CHECK_NAME" ]]; then
                  MATCHED=1
                  human_conclusion=${conclusion:-pending}
                  echo "Found check run '$name' (status: $status, conclusion: $human_conclusion)"

                  if [[ "$status" == "completed" ]]; then
                    conclusion=${conclusion:-unknown}
                    echo "check_name=$name" >> "$GITHUB_OUTPUT"
                    echo "conclusion=$conclusion" >> "$GITHUB_OUTPUT"

                    if [[ "$conclusion" == "success" || "$conclusion" == "neutral" || "$conclusion" == "skipped" ]]; then
                      echo "Check '$name' completed with conclusion '$conclusion' (treated as pass)"
                      exit 0
                    else
                      echo "::error::Check '$name' completed with conclusion '$conclusion'"
                      exit 1
                    fi
                  fi
                fi
              done <<< "$runs"
            fi

            if [[ $MATCHED -eq 0 ]]; then
              echo "Waiting for check matching '$CHECK_NAME' to start..."
            else
              echo "Check found but not completed yet. Waiting..."
            fi

            sleep 30
          done

          echo "check_name=" >> "$GITHUB_OUTPUT"
          echo "conclusion=timed_out" >> "$GITHUB_OUTPUT"
          echo "::error::Timed out waiting for check matching '$CHECK_NAME'"
          exit 1

      - name: Wait for Kubernetes test
        if: ${{ inputs.kubernetes_test_check_name != '' }}
        id: wait-for-kubernetes-test
        env:
          CHECK_NAME: ${{ inputs.kubernetes_test_check_name }}
          GH_TOKEN: ${{ github.token }}
          CHECK_TIMEOUT: 1800
        run: |
          set -euo pipefail

          SHA="${{ github.event.pull_request.head.sha }}"
          REPO="$GITHUB_REPOSITORY"
          deadline=$((SECONDS + CHECK_TIMEOUT))

          while [ $SECONDS -lt $deadline ]; do
            MATCHED=0
            runs=$(gh api repos/$REPO/commits/$SHA/check-runs --paginate --jq '.check_runs[] | "\(.name)\t\(.status)\t\(.conclusion // \"\")"' || true)

            if [ -n "$runs" ]; then
              while IFS=$'\t' read -r name status conclusion; do
                [ -z "$name" ] && continue

                if [[ "$name" == "$CHECK_NAME" || "$name" == *" / $CHECK_NAME" || "$name" == *"$CHECK_NAME" ]]; then
                  MATCHED=1
                  human_conclusion=${conclusion:-pending}
                  echo "Found check run '$name' (status: $status, conclusion: $human_conclusion)"

                  if [[ "$status" == "completed" ]]; then
                    conclusion=${conclusion:-unknown}
                    echo "check_name=$name" >> "$GITHUB_OUTPUT"
                    echo "conclusion=$conclusion" >> "$GITHUB_OUTPUT"

                    if [[ "$conclusion" == "success" || "$conclusion" == "neutral" || "$conclusion" == "skipped" ]]; then
                      echo "Check '$name' completed with conclusion '$conclusion' (treated as pass)"
                      exit 0
                    else
                      echo "::error::Check '$name' completed with conclusion '$conclusion'"
                      exit 1
                    fi
                  fi
                fi
              done <<< "$runs"
            fi

            if [[ $MATCHED -eq 0 ]]; then
              echo "Waiting for check matching '$CHECK_NAME' to start..."
            else
              echo "Check found but not completed yet. Waiting..."
            fi

            sleep 30
          done

          echo "check_name=" >> "$GITHUB_OUTPUT"
          echo "conclusion=timed_out" >> "$GITHUB_OUTPUT"
          echo "::error::Timed out waiting for check matching '$CHECK_NAME'"
          exit 1

      - name: Check if auto-merge is allowed
        id: check-auto-merge
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          ALLOW_MERGE=false
          
          # Check for update types
          if [[ "${{ inputs.allow_patch }}" == "true" && ("$TITLE" == *"patch"* || "$TITLE" == *"Patch"*) ]]; then
            ALLOW_MERGE=true
            echo "✅ Patch update detected and allowed"
          fi
          
          if [[ "${{ inputs.allow_minor }}" == "true" && ("$TITLE" == *"minor"* || "$TITLE" == *"Minor"*) ]]; then
            ALLOW_MERGE=true
            echo "✅ Minor update detected and allowed"
          fi
          
          if [[ "${{ inputs.allow_major }}" == "true" && ("$TITLE" == *"major"* || "$TITLE" == *"Major"*) ]]; then
            ALLOW_MERGE=true
            echo "✅ Major update detected and allowed"
          fi
          
          # Check for additional keywords
          IFS=',' read -ra KEYWORDS <<< "${{ inputs.additional_keywords }}"
          for keyword in "${KEYWORDS[@]}"; do
            if [[ "$TITLE" == *"$keyword"* ]]; then
              ALLOW_MERGE=true
              echo "✅ Keyword '$keyword' detected and allowed"
            fi
          done
          
          echo "allow_merge=$ALLOW_MERGE" >> $GITHUB_OUTPUT

      - name: Enable auto-merge
        if: |
          inputs.enable_auto_merge && 
          steps.check-auto-merge.outputs.allow_merge == 'true' &&
          (steps.wait-for-code-analysis.outputs.conclusion == 'success' || steps.wait-for-code-analysis.outputs.conclusion == 'neutral' || steps.wait-for-code-analysis.outputs.conclusion == 'skipped') &&
          (inputs.container_test_check_name == '' || steps.wait-for-container-test.outputs.conclusion == 'success' || steps.wait-for-container-test.outputs.conclusion == 'neutral' || steps.wait-for-container-test.outputs.conclusion == 'skipped') &&
          (inputs.kubernetes_test_check_name == '' || steps.wait-for-kubernetes-test.outputs.conclusion == 'success' || steps.wait-for-kubernetes-test.outputs.conclusion == 'neutral' || steps.wait-for-kubernetes-test.outputs.conclusion == 'skipped') &&
          github.actor == 'dependabot[bot]'
        run: |
          MERGE_FLAG=""
          case "${{ inputs.merge_method }}" in
            "squash")
              MERGE_FLAG="--squash"
              ;;
            "rebase")
              MERGE_FLAG="--rebase"
              ;;
            "merge")
              MERGE_FLAG="--merge"
              ;;
          esac
          
          DELETE_FLAG=""
          if [[ "${{ inputs.delete_branch }}" == "true" ]]; then
            DELETE_FLAG="--delete-branch"
          fi
          
          gh pr merge --auto $MERGE_FLAG $DELETE_FLAG "${{ github.event.pull_request.number }}" || {
            echo "Failed to enable auto-merge, attempting direct merge since CI passed"
            gh pr merge $MERGE_FLAG $DELETE_FLAG "${{ github.event.pull_request.number }}"
          }
          echo "✅ Merged Dependabot PR: ${{ github.event.pull_request.title }}"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Comment on major updates
        if: |
          github.actor == 'dependabot[bot]' &&
          (contains(github.event.pull_request.title, 'major') || contains(github.event.pull_request.title, 'Major')) &&
          inputs.allow_major == false &&
          (
            (steps.wait-for-code-analysis.outputs.conclusion != 'success' && steps.wait-for-code-analysis.outputs.conclusion != 'neutral' && steps.wait-for-code-analysis.outputs.conclusion != 'skipped') ||
            (inputs.container_test_check_name != '' && steps.wait-for-container-test.outputs.conclusion != 'success' && steps.wait-for-container-test.outputs.conclusion != 'neutral' && steps.wait-for-container-test.outputs.conclusion != 'skipped') ||
            (inputs.kubernetes_test_check_name != '' && steps.wait-for-kubernetes-test.outputs.conclusion != 'success' && steps.wait-for-kubernetes-test.outputs.conclusion != 'neutral' && steps.wait-for-kubernetes-test.outputs.conclusion != 'skipped')
          )
        run: |
          gh pr comment "${{ github.event.pull_request.number }}" --body "⚠️ This is a **major version update** that requires manual review. Please test thoroughly before merging."
        env:
          GITHUB_TOKEN: ${{ github.token }}

      - name: Comment on failed checks
        if: |
          github.actor == 'dependabot[bot]' &&
          steps.check-auto-merge.outputs.allow_merge == 'true' &&
          (
            (steps.wait-for-code-analysis.outputs.conclusion != 'success' && steps.wait-for-code-analysis.outputs.conclusion != 'neutral' && steps.wait-for-code-analysis.outputs.conclusion != 'skipped') ||
            (inputs.container_test_check_name != '' && steps.wait-for-container-test.outputs.conclusion != 'success' && steps.wait-for-container-test.outputs.conclusion != 'neutral' && steps.wait-for-container-test.outputs.conclusion != 'skipped') ||
            (inputs.kubernetes_test_check_name != '' && steps.wait-for-kubernetes-test.outputs.conclusion != 'success' && steps.wait-for-kubernetes-test.outputs.conclusion != 'neutral' && steps.wait-for-kubernetes-test.outputs.conclusion != 'skipped')
          )
        run: |
          gh pr comment "${{ github.event.pull_request.number }}" --body "❌ Auto-merge blocked due to failed CI checks. Please review and fix the issues."
        env:
          GITHUB_TOKEN: ${{ github.token }}