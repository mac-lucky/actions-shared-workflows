---
name: Reusable Go CI/CD Workflow

on:
  workflow_call:
    secrets:
      DOCKER_HUB_USERNAME:
        description: 'Docker Hub username'
        required: false
      DOCKER_HUB_PASSWORD:
        description: 'Docker Hub password/token'
        required: false
      HELM_CHART_REPO_TOKEN:
        description: 'PAT for checking out a private Helm chart repository'
        required: false
    inputs:
      # Application configuration
      app_name:
        description: 'Application name'
        required: true
        type: string
      dockerhub_image:
        description: 'Docker Hub image name (e.g., maclucky/app-name)'
        required: true
        type: string
      ghcr_image:
        description: 'GHCR image name (e.g., ghcr.io/mac-lucky/app-name)'
        required: true
        type: string
      
      # Build configuration
      dockerfile_path:
        description: 'Path to Dockerfile'
        required: false
        type: string
        default: './Dockerfile'
      build_context:
        description: 'Build context path'
        required: false
        type: string
        default: '.'
      
      # Test configuration
      enable_container_tests:
        description: 'Enable container integration tests'
        required: false
        type: boolean
        default: true
      enable_kubernetes_tests:
        description: 'Enable Kubernetes integration tests'
        required: false
        type: boolean
        default: false
      helm_chart_path:
        description: 'Path to Helm chart for Kubernetes tests'
        required: false
        type: string
        default: ''
      helm_chart_repo:
        description: 'External repository containing the Helm chart (e.g., owner/repo). If set, the repo is checked out alongside the main code.'
        required: false
        type: string
        default: ''
      helm_chart_repo_ref:
        description: 'Branch or ref for the external Helm chart repository'
        required: false
        type: string
        default: 'master'
      helm_release_name:
        description: 'Helm release name for deployment'
        required: false
        type: string
        default: ''
      app_label_selector:
        description: 'App label selector for Kubernetes pods (e.g., ping-exporter, tcp-endpoint-check-exporter)'
        required: false
        type: string
        default: ''
      container_test_pre_script:
        description: 'Shell script to run before the container test (e.g., start dependencies)'
        required: false
        type: string
        default: ''
      container_test_run_args:
        description: 'Extra flags for docker run in container test (e.g., env vars, volumes, networks)'
        required: false
        type: string
        default: ''
      container_test_health_url:
        description: 'HTTP URL to curl for container health verification'
        required: false
        type: string
        default: ''
      enable_custom_metrics_test:
        description: 'Enable custom metrics endpoint test with port-forward'
        required: false
        type: boolean
        default: false
      metrics_port:
        description: 'Port for metrics endpoint (e.g., 9107)'
        required: false
        type: string
        default: ''
      metrics_test_pattern:
        description: 'Pattern to search for in metrics output (e.g., ping_loss_ratio)'
        required: false
        type: string
        default: ''

      # Security and quality
      enable_security_scan:
        description: 'Enable security scanning with Trivy'
        required: false
        type: boolean
        default: true
      enable_sbom:
        description: 'Generate Software Bill of Materials'
        required: false
        type: boolean
        default: true
      
      # Deployment
      enable_auto_version:
        description: 'Enable automatic version increment'
        required: false
        type: boolean
        default: true
      push_on_main:
        description: 'Push images when merging to main branch'
        required: false
        type: boolean
        default: true
      push_to_dockerhub:
        description: 'Push images to Docker Hub (in addition to GHCR)'
        required: false
        type: boolean
        default: false
      main_branch:
        description: 'Main branch name used for push gating (e.g., main or master)'
        required: false
        type: string
        default: 'master'

env:
  REGISTRY_IMAGE_DOCKERHUB: ${{ inputs.dockerhub_image }}
  REGISTRY_IMAGE_GHCR: ${{ inputs.ghcr_image }}

jobs:
  # Job 1: Check for code changes
  check-changes:
    name: Check for Code Changes
    runs-on: ubuntu-latest
    outputs:
      code-changed: ${{ steps.changes.outputs.code-changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check for code changes
        id: changes
        uses: mac-lucky/actions-shared-workflows/.github/actions/check-code-changes@master
        with:
          file_patterns: '\.(go|mod|sum)$|Dockerfile|^(src|cmd|internal|pkg)/'
          event_name: ${{ github.event_name }}

  setup:
    name: Setup Build Environment
    runs-on: ubuntu-latest
    needs: check-changes
    outputs:
      go-version: ${{ steps.go-version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Extract Go version from go.mod
        id: go-version
        run: |
          # Extract Go version from go.mod
          GO_VERSION=$(grep "^go " go.mod | cut -d' ' -f2)
          echo "Found Go version in go.mod: $GO_VERSION"

          # Set version for builds
          echo "version=$GO_VERSION" >> $GITHUB_OUTPUT

  # Job 3: Code Quality & Security Analysis (parallel matrix)
  code-analysis:
    name: Code Analysis (${{ matrix.tool }})
    runs-on: ubuntu-latest
    needs: [check-changes, setup]
    strategy:
      fail-fast: false
      matrix:
        include:
          - tool: go-vet
            name: Go Vet
          - tool: staticcheck
            name: Staticcheck
          - tool: trivy
            name: Trivy Security Scan
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ needs.setup.outputs.go-version }}
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        if: matrix.tool == 'go-vet'
        run: go mod verify

      - name: Run go vet
        if: matrix.tool == 'go-vet'
        run: |
          if OUTPUT=$(go vet ./... 2>&1); then
            echo "## :white_check_mark: Go Vet" >> $GITHUB_STEP_SUMMARY
            echo "No issues found." >> $GITHUB_STEP_SUMMARY
          else
            echo "## :x: Go Vet" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$OUTPUT" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Run staticcheck
        if: matrix.tool == 'staticcheck'
        id: staticcheck
        run: |
          go install honnef.co/go/tools/cmd/staticcheck@latest
          if OUTPUT=$(staticcheck ./... 2>&1); then
            echo "## :white_check_mark: Staticcheck" >> $GITHUB_STEP_SUMMARY
            echo "No issues found." >> $GITHUB_STEP_SUMMARY
          else
            echo "## :x: Staticcheck" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$OUTPUT" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Run Trivy vulnerability scanner
        if: matrix.tool == 'trivy' && inputs.enable_security_scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "table"
          output: "trivy-results.txt"

      - name: Trivy job summary
        if: matrix.tool == 'trivy' && inputs.enable_security_scan && always()
        run: |
          if [ ! -s trivy-results.txt ]; then
            echo "## :white_check_mark: Trivy Security Scan" >> $GITHUB_STEP_SUMMARY
            echo "No vulnerabilities found." >> $GITHUB_STEP_SUMMARY
          else
            echo "## :shield: Trivy Security Scan" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat trivy-results.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

  # Job 4: Build Container Image
  build-container:
    name: Build Container Image
    runs-on: ubuntu-latest
    needs: [check-changes, setup, code-analysis]
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build container
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.build_context }}
          file: ${{ inputs.dockerfile_path }}
          tags: ${{ inputs.app_name }}:test
          cache-from: type=gha
          cache-to: type=gha,mode=max
          push: false
          load: true
          build-args: |
            GO_VERSION=${{ needs.setup.outputs.go-version }}

      - name: Save container image
        if: ${{ inputs.enable_kubernetes_tests || inputs.enable_container_tests }}
        run: |
          docker save ${{ inputs.app_name }}:test | \
            gzip > /tmp/${{ inputs.app_name }}.tar.gz

      - name: Upload container artifact
        if: ${{ inputs.enable_kubernetes_tests || inputs.enable_container_tests }}
        uses: actions/upload-artifact@v4
        with:
          name: container-image
          path: /tmp/${{ inputs.app_name }}.tar.gz
          retention-days: 1

  # Job 5: Container Integration Tests
  container-test:
    name: Container Integration Test
    runs-on: ubuntu-latest
    needs: [check-changes, setup, build-container]
    if: ${{ inputs.enable_container_tests }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download container artifact
        uses: actions/download-artifact@v5
        with:
          name: container-image
          path: /tmp

      - name: Container health check
        uses: mac-lucky/actions-shared-workflows/.github/actions/container-healthcheck@master
        with:
          image_tar: /tmp/${{ inputs.app_name }}.tar.gz
          container_name: ${{ inputs.app_name }}
          enable_security_scan: ${{ inputs.enable_security_scan }}
          pre_test_script: ${{ inputs.container_test_pre_script }}
          docker_run_args: ${{ inputs.container_test_run_args }}
          health_check_url: ${{ inputs.container_test_health_url }}

  # Job 6: Kubernetes Integration Tests (Optional)
  kubernetes-test:
    name: Kubernetes Integration Test
    runs-on: ubuntu-latest
    needs: [check-changes, setup, build-container]
    if: ${{ inputs.enable_kubernetes_tests && inputs.helm_chart_path != '' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Checkout Helm chart repository
        if: ${{ inputs.helm_chart_repo != '' }}
        uses: actions/checkout@v5
        with:
          repository: ${{ inputs.helm_chart_repo }}
          ref: ${{ inputs.helm_chart_repo_ref }}
          path: helm-chart-repo
          token: ${{ secrets.HELM_CHART_REPO_TOKEN || github.token }}

      - name: Download container artifact
        uses: actions/download-artifact@v5
        with:
          name: container-image
          path: /tmp

      - name: Load container image
        run: |
          gunzip -c /tmp/${{ inputs.app_name }}.tar.gz | docker load
          docker image ls -a

      - name: Setup Minikube
        uses: mac-lucky/actions-shared-workflows/.github/actions/setup-minikube@master

      - name: Load Docker image into Minikube
        run: |
          minikube image load ${{ inputs.app_name }}:test

      - name: Deploy with Helm
        uses: mac-lucky/actions-shared-workflows/.github/actions/helm-deploy@master
        with:
          chart_path: ${{ inputs.helm_chart_repo != '' && format('./helm-chart-repo/{0}', inputs.helm_chart_path) || inputs.helm_chart_path }}
          release_name: ${{ inputs.helm_release_name != '' && inputs.helm_release_name || inputs.app_name }}
          app_name: ${{ inputs.app_name }}

      - name: Kubernetes health check
        uses: mac-lucky/actions-shared-workflows/.github/actions/kubernetes-healthcheck@master
        with:
          app_label_selector: ${{ inputs.app_label_selector != '' && inputs.app_label_selector || inputs.app_name }}

      - name: Check logs
        run: |
          APP_LABEL="${{ inputs.app_label_selector }}"
          if [ -z "$APP_LABEL" ]; then
            APP_LABEL="${{ inputs.app_name }}"
          fi

          sleep 30
          echo "=== Application logs ==="
          kubectl logs -l app=$APP_LABEL -n monitoring --tail=50

      - name: Test metrics endpoint
        if: ${{ inputs.enable_custom_metrics_test }}
        run: |
          RELEASE_NAME="${{ inputs.helm_release_name }}"
          if [ -z "$RELEASE_NAME" ]; then
            RELEASE_NAME="${{ inputs.app_name }}"
          fi

          echo "=== Testing metrics endpoint ==="
          kubectl port-forward -n monitoring svc/$RELEASE_NAME ${{ inputs.metrics_port }}:${{ inputs.metrics_port }} &
          PF_PID=$!
          sleep 10

          # Test metrics endpoint
          response=$(curl -s http://localhost:${{ inputs.metrics_port }}/metrics)
          if echo "$response" | grep -q "${{ inputs.metrics_test_pattern }}"; then
            echo "✅ Metrics endpoint working - ${{ inputs.metrics_test_pattern }} found"
            echo "Sample metrics:"
            echo "$response" | head -20
          else
            echo "❌ Metrics endpoint not working - ${{ inputs.metrics_test_pattern }} not found"
            echo "Response received:"
            echo "$response"
            kill $PF_PID || true
            exit 1
          fi

          # Cleanup
          kill $PF_PID || true

      - name: Cleanup
        if: always()
        run: |
          RELEASE_NAME="${{ inputs.helm_release_name }}"
          if [ -z "$RELEASE_NAME" ]; then
            RELEASE_NAME="${{ inputs.app_name }}"
          fi
          
          helm uninstall $RELEASE_NAME -n monitoring || true
          kubectl delete namespace monitoring || true

  # Job 7: Build platform-specific images in parallel (native runners with QEMU fallback for private repos)
  build:
    name: Build (${{ matrix.platform }})
    # Use native ARM runner for public repos, fallback to QEMU on ubuntu-latest for private repos
    runs-on: ${{ (matrix.platform == 'linux/arm64' && github.event.repository.private) && 'ubuntu-latest' || matrix.runner }}
    needs: [check-changes, setup, build-container, container-test, kubernetes-test]
    if: ${{ ((github.event_name == 'push' && inputs.push_on_main) || github.event_name == 'release' || github.event_name == 'workflow_dispatch') && github.ref == format('refs/heads/{0}', inputs.main_branch) && needs.check-changes.outputs.code-changed == 'true' && (always() && (inputs.enable_container_tests == false || needs.container-test.result == 'success' || needs.container-test.result == 'skipped') && (inputs.enable_kubernetes_tests == false || needs.kubernetes-test.result == 'success' || needs.kubernetes-test.result == 'skipped')) }}
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    outputs:
      new-version: ${{ steps.set_version.outputs.new_version }}
    steps:
      - name: Prepare platform pair
        run: |
          platform=${{ matrix.platform }}
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV

      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up QEMU (fallback for private repos)
        if: ${{ matrix.platform == 'linux/arm64' && github.event.repository.private }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: ${{ inputs.push_to_dockerhub }}
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}

      - name: Get latest version tag
        if: ${{ inputs.enable_auto_version }}
        id: get_latest_version
        run: |
          # Extract image name from GHCR URL (e.g., ghcr.io/mac-lucky/app-name -> app-name)
          IMAGE_NAME=$(echo "${{ env.REGISTRY_IMAGE_GHCR }}" | sed 's|.*/||')
          OWNER=$(echo "${{ env.REGISTRY_IMAGE_GHCR }}" | sed 's|ghcr.io/||' | sed 's|/.*||')

          # Get tags from GHCR using GitHub API
          LATEST_TAG=$(curl -s \
            -H "Authorization: Bearer ${{ github.token }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/users/$OWNER/packages/container/$IMAGE_NAME/versions?per_page=100" | \
            jq -r '.[].metadata.container.tags[]' | \
            grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | \
            sort -V | tail -n 1 || echo "")
          echo "LATEST_TAG=${LATEST_TAG}" >> $GITHUB_ENV

      - name: Set version
        id: set_version
        run: |
          if [ "${{ inputs.enable_auto_version }}" = "true" ]; then
            VERSION=${{ env.LATEST_TAG }}
            if [ -z "$VERSION" ]; then
              NEW_VERSION="1.0.0"
            else
              NEW_VERSION=$(echo $VERSION | awk -F. -v OFS=. '{$NF++;print}')
            fi
          else
            # Use git tag or default version
            NEW_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "1.0.0")
          fi
          echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_ENV
          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_IMAGE_GHCR }}
          tags: |
            type=raw,value=${{ env.NEW_VERSION }}
            type=raw,value=latest

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.build_context }}
          file: ${{ inputs.dockerfile_path }}
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            GO_VERSION=${{ needs.setup.outputs.go-version }}
            VERSION=${{ env.NEW_VERSION }}
            COMMIT_SHA=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
          outputs: type=image,name=${{ env.REGISTRY_IMAGE_GHCR }},push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=build-${{ env.PLATFORM_PAIR }}
          cache-to: type=gha,scope=build-${{ env.PLATFORM_PAIR }},mode=max

      - name: Export digest
        run: |
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ env.PLATFORM_PAIR }}
          path: ${{ runner.temp }}/digests/*
          if-no-files-found: error
          retention-days: 1

  # Job 8: Merge platform-specific images into multi-arch manifest
  merge:
    name: Create Multi-arch Manifest
    runs-on: ubuntu-latest
    needs: [check-changes, setup, build]
    if: ${{ always() && needs.build.result == 'success' && ((github.event_name == 'push' && inputs.push_on_main) || github.event_name == 'release' || github.event_name == 'workflow_dispatch') && github.ref == format('refs/heads/{0}', inputs.main_branch) && needs.check-changes.outputs.code-changed == 'true' }}
    permissions:
      contents: read
      packages: write
      security-events: write
    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: ${{ runner.temp }}/digests
          pattern: digests-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Prepare version
        run: |
          echo "NEW_VERSION=${{ needs.build.outputs.new-version }}" >> $GITHUB_ENV

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_IMAGE_GHCR }}
          tags: |
            type=raw,value=${{ env.NEW_VERSION }}
            type=raw,value=latest

      - name: Log in to Docker Hub
        if: ${{ inputs.push_to_dockerhub }}
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}

      - name: Create manifest list and push (GHCR)
        working-directory: ${{ runner.temp }}/digests
        run: |
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.REGISTRY_IMAGE_GHCR }}@sha256:%s ' *)

      - name: Create manifest list and push (Docker Hub)
        if: ${{ inputs.push_to_dockerhub }}
        working-directory: ${{ runner.temp }}/digests
        run: |
          docker buildx imagetools create \
            -t ${{ env.REGISTRY_IMAGE_DOCKERHUB }}:${{ env.NEW_VERSION }} \
            -t ${{ env.REGISTRY_IMAGE_DOCKERHUB }}:latest \
            $(printf '${{ env.REGISTRY_IMAGE_DOCKERHUB }}@sha256:%s ' *)

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ env.REGISTRY_IMAGE_GHCR }}:${{ env.NEW_VERSION }}

      - name: Generate SBOM
        if: ${{ inputs.enable_sbom }}
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY_IMAGE_GHCR }}:${{ env.NEW_VERSION }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM artifact
        if: ${{ inputs.enable_sbom }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json

  # Job 9: Post-deployment verification
  post-deploy-verify:
    name: Post-deployment Verification
    runs-on: ubuntu-latest
    needs: [check-changes, merge]
    if: ${{ always() && needs.merge.result == 'success' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && github.ref == format('refs/heads/{0}', inputs.main_branch) }}
    steps:
      - name: Verify deployed image
        uses: mac-lucky/actions-shared-workflows/.github/actions/verify-deployed-image@master
        with:
          registry_image: ${{ env.REGISTRY_IMAGE_GHCR }}
          github_token: ${{ github.token }}